(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9681],{3220:(e,t,r)=>{"use strict";r.d(t,{_:()=>a});class a{getItem(e){let t=this.data[e];return void 0!==t?t:null}setItem(e,t){this.data[e]=String(t)}removeItem(e){delete this.data[e]}constructor(){this.data={}}}},7537:(e,t,r)=>{"use strict";r.d(t,{A:()=>n});var a=r(39972),i=r(15453);function n(e,t){let{request:r,signingPublicKey:n,publicKey:o,hdWalletIndex:s}=t;if(void 0!==s&&0!==s&&void 0===n)throw new a.Pi("invalid_request_arguments","signingPublicKey must be passed when signing with a wallet with an HD index that is not 0.");return i.p({keypair:e,request:r,expectedPublicKey:null!=n?n:o})}},7553:(e,t,r)=>{"use strict";r.d(t,{o:()=>a});let a=(0,r(78273).x)({id:998,name:"HyperEVM Testnet",nativeCurrency:{decimals:18,name:"HYPE",symbol:"HYPE"},rpcUrls:{default:{http:["https://rpc.hyperliquid-testnet.xyz/evm"]},privy:{http:["https://hyperevm-testnet.rpc.privy.systems"]},privyInternal:{http:["https://long-skilled-brook.hype-testnet.quiknode.pro/fff674b07bd5e793bdb6accfe30267f26c0a67e0/evm"]}},blockExplorers:{default:{name:"HyperEVM Testnet Explorer",url:""}}})},10163:()=>{},12192:(e,t,r)=>{"use strict";r.d(t,{Ay:()=>x,Bt:()=>b,CD:()=>h.CD,CI:()=>j,EN:()=>Y,IV:()=>I,IX:()=>M,LH:()=>T,M4:()=>q,MC:()=>f.MC,MR:()=>g,Pp:()=>R,UI:()=>k,Ud:()=>D,WQ:()=>z,Wi:()=>F,YZ:()=>H,Zf:()=>U,eB:()=>S,fj:()=>f.fj,hE:()=>B,jt:()=>_,kG:()=>N,kS:()=>W,nz:()=>Z,p$:()=>A,py:()=>K,qi:()=>P,s5:()=>O,sr:()=>E,st:()=>C,t5:()=>V,uY:()=>G,vb:()=>$,zT:()=>L});var a=r(66875),i=r(86989),n=r(95877),o=r(64251),s=r(42135),c=r(85432),l=r(87264),d=r(31096),p=r(25365),u=r(41352),y=r(79481),v=r(15453),h=r(56496),f=r(99798),w=r(36001).Buffer;function m(e){return crypto.getRandomValues(new Uint8Array(e))}function _(e){return"string"==typeof e&&/^[a-zA-Z0-9!@#$%^&*()\-_+.]{6,}$/.test(e)}async function g(e){return{deviceShares:await G(e),recoveryShares:await G(e)}}async function b(e){let t=e.startsWith("0x")?e.slice(2):e,r=new Uint8Array(w.from(t,"hex").buffer),{deviceShares:a,recoveryShares:i}=await g(r),n=(0,u.R)("0x".concat(t));return{chainType:"ethereum",deviceShares:a,recoveryShares:i,wallet:n,entropy:r,signMessage:n.signMessage}}async function k(e){let t=a.tw.decode(e),{deviceShares:r,recoveryShares:i}=await g(t),n=o.Keypair.fromSecretKey(t),s=n.publicKey.toBase58();return{chainType:"solana",deviceShares:r,recoveryShares:i,wallet:n,address:s,signMessage:e=>{let{message:t}=e;return(0,v.x)(n,s,w.from(t).toString("base64"))},entropy:t}}async function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:128;if(![128,160,192,224,256].includes(e))throw Error("invalid entropy size");let t=m(e/8),{deviceShares:r,recoveryShares:a}=await g(t),i=x({entropy:t,walletIndex:0});return{entropy:t,deviceShares:r,recoveryShares:a,wallet:i}}async function I(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:256;if(![256].includes(e))throw Error("invalid entropy size");let t=m(e/8),{deviceShares:r,recoveryShares:a}=await g(t);return{deviceShares:r,recoveryShares:a,keypair:N({entropy:t,index:0}),entropy:t}}function P(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return(0,l.P)(e,{strict:t})}function U(e){try{let t=new o.J3(e);return o.J3.isOnCurve(t)}catch(e){return!1}}function K(e){return(0,d.b)(e)}function T(e,t){return K(e)===K(t)}async function A(e){let{shares:t,primaryAddress:r,walletIndex:a}=e,i=await (0,c.k)(t),n=x({entropy:i,walletIndex:a});if(!T(0===a?n.address:x({entropy:i,walletIndex:0}).address,r))throw Error("Failed to reconstruct the expected wallet from Shamir shares");return{chainType:"ethereum",entropyType:"hd-entropy",wallet:n,entropy:i,walletIndex:a}}function x(e){let{entropy:t,walletIndex:r}=e;return S({entropy:t,opts:{addressIndex:r}})}function S(e){let{entropy:t,opts:r}=e;return(0,y.f)((0,i.VF)(t,n.p),r)}function C(e){let{entropy:t}=e;return(0,u.R)((0,p.nj)(t))}function F(e){let{entropy:t}=e;return o.Keypair.fromSecretKey(t)}async function R(e){let{shares:t,expectedAddress:r}=e,a=await (0,c.k)(t),i=C({entropy:a});if(i.address!==r)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedWallet:i,reconstructedPrivateKey:a}}async function M(e){let{shares:t,expectedAddress:r}=e,a=await (0,c.k)(t),i=o.Keypair.fromSecretKey(a);if(i.publicKey.toBase58()!==r)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedKeypair:i,reconstructedPrivateKey:a}}function N(e){let{entropy:t,index:r}=e,a=s.Ay.fromMasterSeed(w.from(t).toString("hex"));return o.Keypair.fromSeed(a.derive("m/44'/501'/".concat(r,"'/0'")).privateKey)}async function q(e){let{shares:t,expectedPublicKey:r,index:a}=e,i=await (0,c.k)(t),n=N({entropy:i,index:a});if((0===a?n:N({entropy:i,index:0})).publicKey.toBase58()!==r)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{reconstructedKeypair:n,reconstructedEntropy:i}}function G(e){return(0,c.l)(e,2,2)}function V(e,t,r,a){return"".concat(e," wants you to sign in with your Ethereum account:\n").concat(r,"\n\nYou are proving you own ").concat(r,".\n\nURI: ").concat(t,"\nVersion: 1\nChain ID: 1\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function L(e,t,r,a){return"".concat(e," wants you to sign in with your Solana account:\n").concat(r,"\n\nYou are proving you own ").concat(r,".\n\nURI: ").concat(t,"\nVersion: 1\nChain ID: mainnet\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function O(){return m(32)}function B(){return a.tw.encode(m(16))}function D(e,t){return Q(et(e),t)}function j(){return crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function z(e){return new Uint8Array(await crypto.subtle.exportKey("raw",e))}function W(e){return crypto.subtle.importKey("raw",e,"AES-GCM",!0,["encrypt","decrypt"])}async function Y(e){let t=await crypto.subtle.exportKey("raw",e);return await J(t)}async function H(e){let t=et(e);return await J(t)}async function J(e){return new Uint8Array(await crypto.subtle.digest("SHA-256",e))}async function $(e,t){let r=m(12);return{encryptedShare:await X(e,r,t),encryptedShareIV:r}}function Z(e,t,r){return ee(e,t,r)}async function Q(e,t){if(32!==t.byteLength)throw Error("pbkdf2 salt length should be 32 bytes");let r=await crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:t,hash:"SHA-512",iterations:21e5},r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function X(e,t,r){return new Uint8Array(await crypto.subtle.encrypt({iv:t,name:"AES-GCM"},r,e))}async function ee(e,t,r){return new Uint8Array(await crypto.subtle.decrypt({iv:t,name:"AES-GCM"},r,e))}function et(e){return new TextEncoder().encode(e)}},15093:(e,t,r)=>{"use strict";r.d(t,{n:()=>a});let a=(e,t)=>{throw null!=t?t:Error("Expected never, got: ".concat(e))}},15453:(e,t,r)=>{"use strict";r.d(t,{p:()=>s,x:()=>o});var a=r(78007),i=r.n(a),n=r(36001).Buffer;async function o(e,t,r){var a=e.publicKey;if(a.toString()!==t)throw Error("Signer ".concat(a.toBase58()," cannot sign on behalf of ").concat(t));let o=n.from(r,"base64");try{let t=i().sign.detached(o,e.secretKey);return n.from(t).toString("base64")}catch(e){throw console.error(e),e}}async function s(e){let{keypair:t,request:r,expectedPublicKey:a}=e,{method:i,params:n}=r;if("signMessage"===i)return{method:i,data:{signature:await o(t,a,n.message)}};throw Error("Unsupported method: ".concat(i))}},16088:(e,t,r)=>{"use strict";r.d(t,{NG:()=>eg,vo:()=>em,vh:()=>e_});var a=r(30666),i=r(21796),n=r(72419),o=r(63390),s=r(63056),c=r(42355),l=r(62971),d=r(60405),p=r(39e3),u=r(2466),y=r(13390),v=r(47730),h=r(8115),f=r(29712),w=r(61998),m=r(67715),_=r(7981),g=r(54962),b=r(83153),k=r(67227),E=r(51061),I=r(6726),P=r(14932),U=r(40903),K=r(67519),T=r(3198),A=r(88464),x=r(90670),S=r(14914),C=r(30219),F=r(62910),R=r(92017),M=r(38078),N=r(47739),q=r(43896),G=r(43502),V=r(92633),L=r(39133),O=r(49085),B=r(58091),D=r(21411),j=r(60877),z=r(80224),W=r(72637),Y=r(23651),H=r(45102),J=r(86859),$=r(76040),Z=r(34364),Q=r(22289),X=r(32034),ee=r(14433),et=r(43371),er=r(80066),ea=r(3510),ei=r(28780),en=r(60147),eo=r(28304),es=r(78273);let ec=(0,es.x)({id:69e3,name:"Animechain",nativeCurrency:{decimals:18,name:"ANIME",symbol:"ANIME"},rpcUrls:{default:{http:["https://rpc-animechain-39xf6m45e3.t.conduit.xyz"],webSocket:["wss://rpc-animechain-39xf6m45e3.t.conduit.xyz"]}},explorers:{default:{name:"Animechain Explorer"}}}),el=(0,es.x)({id:6900,name:"Animechain Testnet",nativeCurrency:{decimals:18,name:"ANIME",symbol:"ANIME"},rpcUrls:{default:{http:["https://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"],webSocket:["wss://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"]}},blockExplorers:{default:{name:"Explorer",url:"https://explorer-animechain-testnet-i8yja6a1a0.t.conduit.xyz"}}}),ed=(0,es.x)({id:3343,name:"Edge",nativeCurrency:{name:"Edge",symbol:"EDGE",decimals:18},rpcUrls:{default:{http:["https://edge-mainnet.g.alchemy.com/v2/p7XZ9PmQlUFoTRxwIeB38"]}},blockExplorers:{default:{name:"Edge Explorer",url:"https://edge-mainnet.explorer.alchemy.com"}},testnet:!1});var ep=r(20274),eu=r(7553);let ey=(0,es.x)({id:4326,blockTime:1e3,name:"MegaETH",nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},rpcUrls:{default:{http:["https://mainnet.megaeth.com/rpc"],webSocket:["wss://mainnet.megaeth.com/ws"]}},blockExplorers:{default:{name:"Etherscan",url:"https://mega.etherscan.io",apiUrl:"https://api.etherscan.io/v2/api"},blockscout:{name:"Etherscan",url:"https://mega.etherscan.io",apiUrl:"https://api.etherscan.io/v2/api"}},contracts:{multicall3:{address:"0xcA11bde05977b3631167028862bE2a173976CA11",blockCreated:0}}});var ev=r(60439),eh=r(84178);let ef=(0,es.x)({id:8765,name:"Warden",nativeCurrency:{name:"Warden",symbol:"WARD",decimals:18},rpcUrls:{default:{http:["https://evm.wardenprotocol.org"]}},blockExplorers:{default:{name:"Warden Explorer",url:"https://explorer.wardenprotocol.org"}}}),ew={[n.b.id]:{...n.b,rpcUrls:{...n.b.rpcUrls,privy:{http:["https://abs.rpc.privy.systems"]}}},[o.g.id]:{...o.g,rpcUrls:{...o.g.rpcUrls,privy:{http:["https://abs-testnet.rpc.privy.systems"]}}},[ec.id]:ec,[el.id]:el,[s.O.id]:{...s.O,rpcUrls:{...s.O.rpcUrls,privy:{http:["https://apechain-mainnet.rpc.privy.systems"]}}},[c.T.id]:{...c.T,rpcUrls:{...c.T.rpcUrls,privy:{http:["https://apechain-curtis.rpc.privy.systems"]}}},[l.D.id]:{...l.D,rpcUrls:{...l.D.rpcUrls,privy:{http:["https://arbitrum-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://fragrant-nameless-voice.arbitrum-mainnet.quiknode.pro/d5ede1d872f61ca465685a9e08928a0256fa8b0d"]}}},[d.R.id]:d.R,[p.Y.id]:{...p.Y,rpcUrls:{...p.Y.rpcUrls,privy:{http:["https://arbitrum-sepolia.rpc.privy.systems"]},privyInternal:{http:["https://soft-dark-surf.arbitrum-sepolia.quiknode.pro/689e47a7bda68d3964d650cd58fe163caeb0ab87"]}}},[u.m.id]:{...u.m,rpcUrls:{...u.m.rpcUrls,privy:{http:["https://avalanche-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://responsive-broken-owl.avalanche-mainnet.quiknode.pro/2233f2a49b147da704f53ae73553912d83ffb598/ext/bc/C/rpc"]}}},[y.C.id]:{...y.C,rpcUrls:{...y.C.rpcUrls,privyInternal:{http:["https://quick-attentive-uranium.avalanche-testnet.quiknode.pro/89d5550a095b80f1e08100f5e87d72e6a7b339bb/ext/bc/C/rpc"]}}},[v.b3.id]:{...v.b3,rpcUrls:{...v.b3.rpcUrls,privy:{http:["https://b3-mainnet.rpc.privy.systems"]}}},[h.x.id]:{...h.x,rpcUrls:{...h.x.rpcUrls,privy:{http:["https://b3-sepolia.rpc.privy.systems"]}}},[f.E.id]:{...f.E,rpcUrls:{...f.E.rpcUrls,default:{http:["https://thrumming-thrumming-pool.base-mainnet.quiknode.pro/afc8a0038cd744f30fd210e6f8c6b59ed5817bd7"]},privy:{http:["https://base-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://fittest-wild-frog.base-mainnet.quiknode.pro/3474cf7682996021cbed75bfb11ec811dfed6ac2"]}}},[w.C.id]:m.h,[_.Z.id]:{..._.Z,rpcUrls:{..._.Z.rpcUrls,privy:{http:["https://base-sepolia.rpc.privy.systems"]},privyInternal:{http:["https://convincing-radial-fog.base-sepolia.quiknode.pro/88a4344ee41e533489e61d5ce0fc056427e6a300"]}}},[g._.id]:{...g._,rpcUrls:{...g._.rpcUrls,privy:{http:["https://berachain-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://holy-special-frog.bera-mainnet.quiknode.pro/f7e9c0c78b563f8c523f26ddd7f059f8cfa87815"]}}},[b.J.id]:b.J,[k.N.id]:{...k.N,rpcUrls:{...k.N.rpcUrls,privy:{http:["https://bsc-mainnet.rpc.privy.systems"]},default:{http:["https://quiet-burned-dust.bsc.quiknode.pro/a0d86563bc5d99e49d7d72ca422da0e761b4e257"]},privyInternal:{http:["https://quiet-burned-dust.bsc.quiknode.pro/a0d86563bc5d99e49d7d72ca422da0e761b4e257"]}}},[E.v.id]:{...E.v,rpcUrls:{...E.v.rpcUrls,privy:{http:["https://blast-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://solemn-quaint-wave.blast-mainnet.quiknode.pro/3c46fec2cb08af962d6cafaf27bcaf88c83a445e"]}}},[I._.id]:{...I._,rpcUrls:{...I._.rpcUrls,privyInternal:{http:["https://lively-soft-crater.blast-sepolia.quiknode.pro/1edf7cc37566abfcf8f8c711550cf3062c80418e"]}}},[P.A.id]:{...P.A,rpcUrls:{...P.A.rpcUrls,privyInternal:{http:["https://burned-boldest-spree.celo-mainnet.quiknode.pro/701b6130a1791c98636339709fb2bc0db17386c3"]}}},[U.p.id]:U.p,[ed.id]:ed,[K.r.id]:{...K.r,rpcUrls:{...K.r.rpcUrls,default:{http:["https://crimson-wider-silence.quiknode.pro/50060fe02eaca407606719d97f4f204f28da43ed"]},privy:{http:["https://mainnet.rpc.privy.systems"]},privyInternal:{http:["https://convincing-chaotic-shard.quiknode.pro/2938f488262e10f0ace44735bc33c936e3f77e07"]}}},[m.h.id]:m.h,[T.G.id]:{...T.G,rpcUrls:{...T.G.rpcUrls,default:{http:["https://quaint-morning-star.ethereum-sepolia.quiknode.pro/0063bd92e4f0adaa5b76cbd168121be661100ed9/"]},privy:{http:["https://sepolia.rpc.privy.systems"]},privyInternal:{http:["https://winter-withered-pool.ethereum-sepolia.quiknode.pro/1ff40c6d363faac7514f9633ee958e71c6f007c4"]}}},[A.y.id]:A.y,[x.G.id]:x.G,[S.O.id]:S.O,[C.l.id]:{...C.l,rpcUrls:{...C.l.rpcUrls,privy:{http:["https://flow-mainnet.rpc.privy.systems"]}}},[F.m.id]:{...F.m,rpcUrls:{...F.m.rpcUrls,privy:{http:["https://fluent-testnet.rpc.privy.systems"]}}},[R.f.id]:{...R.f,rpcUrls:{...R.f.rpcUrls,privy:{http:["https://gunz-mainnet.rpc.privy.systems"]}}},[ep.J.id]:ep.J,[eu.o.id]:eu.o,[M.E.id]:{...M.E,rpcUrls:{...M.E.rpcUrls,privy:{http:["https://immutable-mainnet.rpc.privy.systems"]}}},[N.P.id]:{...N.P,rpcUrls:{...N.P.rpcUrls,privy:{http:["https://ink-mainnet.rpc.privy.systems"]}}},[q.e.id]:{...q.e,rpcUrls:{...q.e.rpcUrls,privy:{http:["https://ink-sepolia.rpc.privy.systems"]}}},[G._.id]:{...G._,rpcUrls:{...G._.rpcUrls,privyInternal:{http:["https://wiser-muddy-pallet.linea-mainnet.quiknode.pro/7838ef59fa41a994252afa35b0d982b6331a0f39"]}}},[V.Z.id]:V.Z,[L.F.id]:L.F,[ey.id]:{...ey,rpcUrls:{...ey.rpcUrls,privy:{http:["https://megaeth-mainnet.rpc.privy.systems"]}}},[O.B.id]:{...O.B,rpcUrls:{...O.B.rpcUrls,privy:{http:["https://megaeth-testnet.rpc.privy.systems"]}}},[ev.c.id]:ev.c,[B.F.id]:{...B.F,rpcUrls:{...B.F.rpcUrls,privy:{http:["https://monad-testnet.rpc.privy.systems"]},privyInternal:{http:["https://bold-damp-pallet.monad-testnet.quiknode.pro/7c89c1d5c820434df06751edeb3766ff8191e066"]}}},[eh.l.id]:{...eh.l,rpcUrls:{...eh.l.rpcUrls,privy:{http:["https://neura-testnet.rpc.privy.systems"]}}},[D.R.id]:{...D.R,rpcUrls:{...D.R.rpcUrls,privy:{http:["https://optimism-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://wiser-maximum-wind.optimism.quiknode.pro/2b589e60ecc57b5fa0f9072095d94688e5d12a3a"]}}},[j.t.id]:j.t,[z.i.id]:{...z.i,rpcUrls:{...z.i.rpcUrls,privy:{http:["https://optimism-sepolia.rpc.privy.systems"]},privyInternal:{http:["https://still-alien-sailboat.optimism-sepolia.quiknode.pro/d0eeb804d0819460def751002c668f9e516e6d89"]}}},[W.n.id]:{...W.n,rpcUrls:{...W.n.rpcUrls,privy:{http:["https://polygon-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://cosmological-greatest-dew.matic.quiknode.pro/270a55743ed292cdc3584bedb02d11ff04ee0254"]}}},[Y.n.id]:{...Y.n,rpcUrls:{...Y.n.rpcUrls,privy:{http:["https://polygon-amoy.rpc.privy.systems"]},privyInternal:{http:["https://blue-damp-putty.matic-amoy.quiknode.pro/0794ce42ea9006c75fb07eca4ad2c43765b26ed4"]}}},[H.E.id]:H.E,[J.L.id]:{...J.L,rpcUrls:{...J.L.rpcUrls,privy:{http:["https://ronin-mainnet.rpc.privy.systems"]}}},[$.s.id]:{...$.s,rpcUrls:{...$.s.rpcUrls,privy:{http:["https://ronin-saigon.rpc.privy.systems"]}}},[Z.a.id]:{...Z.a,rpcUrls:{...Z.a.rpcUrls,privy:{http:["https://sei-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://virulent-green-owl.sei-pacific.quiknode.pro/4bb48190d71262a8b2445c8d428415487f299d7e"]}}},[Q.c.id]:{...Q.c,rpcUrls:{...Q.c.rpcUrls,privy:{http:["https://shape-mainnet.rpc.privy.systems"]}}},[X.M.id]:{...X.M,rpcUrls:{...X.M.rpcUrls,privy:{http:["https://somnia-mainnet.rpc.privy.systems"]}}},[ee.r.id]:{...ee.r,rpcUrls:{...ee.r.rpcUrls,privy:{http:["https://somnia-testnet.rpc.privy.systems"]}}},[et.J.id]:{...et.J,rpcUrls:{...et.J.rpcUrls,privy:{http:["https://soneium-mainnet.rpc.privy.systems"]}}},[er._.id]:er._,[ea.k.id]:{...ea.k,rpcUrls:{...ea.k.rpcUrls,privy:{http:["https://unichain-mainnet.rpc.privy.systems"]}}},[ef.id]:ef,[ei.u.id]:{...ei.u,rpcUrls:{...ei.u.rpcUrls,privyInternal:{http:["https://wild-proportionate-snow.worldchain-mainnet.quiknode.pro/823ce20c28dcb8793e04dc47d5841ebf3e449436"]}}},[en.L.id]:{...en.L,rpcUrls:{...en.L.rpcUrls,privy:{http:["https://zora-mainnet.rpc.privy.systems"]}}},[eo.a.id]:eo.a},em=e=>{let t=ew[e];if(!t)throw Error("Unsupported chainId ".concat(e));return t},e_=(e,t)=>{var r,n,o;let s,c=em(e);if(null==(r=c.rpcUrls.privy)?void 0:r.http[0]){let e=new URL(c.rpcUrls.privy.http[0]);e.searchParams.append("privyAppId",t),s=e.toString()}else if(null==(n=c.rpcUrls.infura)?void 0:n.http[0]){if(!i.A.PRIVY_INFURA_ID)throw Error("Missing Infura ID for RPC URL");s=(0,a.j)({origin:c.rpcUrls.infura.http[0],path:i.A.PRIVY_INFURA_ID})}else s=null==(o=c.rpcUrls.default)?void 0:o.http[0];if(!s)throw Error("No RPC url found for ".concat(e));return s},eg=e=>{if(e.startsWith("eip155:"))return Number(e.split(":")[1]);throw Error("Not an EVM CAIP2: ".concat(e))}},16150:(e,t,r)=>{"use strict";r.d(t,{_:()=>c,k:()=>o});var a=r(22876),i=r(35102);let n={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844",4:"eip7702"},o={legacy:0,eip2930:1,eip1559:2,eip4844:3,eip7702:4},s=e=>void 0!==e?BigInt(e):void 0;function c(e){let t,{type:r=2,...o}="string"==typeof e?JSON.parse(e):e;o.accessList&&Array.isArray(o.accessList)?t=o.accessList.map(e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e):o.accessList&&(t=Object.entries(o.accessList).map(e=>({address:e[0],storageKeys:e[1]})));let c=Number(o.chainId??1),l=(0,a.q)(o.data)?o.data:o.data?(0,i.nj)(Uint8Array.from(o.data)):void 0,d=o.nonce?Number(o.nonce):void 0,p={chainId:c,data:l,nonce:d,value:s(o.value),gas:s(o.gas??o.gasLimit)},u=Number(r);if(0===u)return{...o,type:n[u],...p,gasPrice:s(o.gasPrice),accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===u)return{...o,type:n[u],...p,gasPrice:s(o.gasPrice),accessList:t,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===u)return{...o,type:n[u],...p,nonce:d,accessList:t,maxFeePerGas:s(o.maxFeePerGas),maxPriorityFeePerGas:s(o.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw Error(`Unsupported transaction type: ${r}`)}},20274:(e,t,r)=>{"use strict";r.d(t,{J:()=>a});let a=(0,r(78273).x)({id:999,name:"HyperEVM Mainnet",nativeCurrency:{decimals:18,name:"HYPE",symbol:"HYPE"},rpcUrls:{default:{http:["https://rpc.hyperliquid.xyz/evm"]},privy:{http:["https://hyperevm-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://wider-weathered-market.hype-mainnet.quiknode.pro/76421d5d42278daccc28e24cde1d165c6a2a6daf/evm"]}},blockExplorers:{default:{name:"HyperEVM Mainnet Explorer",url:""}}})},21796:(e,t,r)=>{"use strict";r.d(t,{A:()=>m});var a=r(72986),i=r(59200),n=r(23727);let o="cla04x0d00002nyb6oofp5dqh",s=n.env.MY_PRIVY_APP_ID,c=n.env.VERCEL_GIT_COMMIT_SHA,l=n.env.VERCEL_GIT_COMMIT_REF,d="pk_live_51IVGUtF66LfGv8cgubvAHN9hcEUMJJOvprWKjAUEhuWCQsQZHGE5b1PDzChVsiIjyCOCbmqpgtH9cQAemzTIuG3600x1ub2mo9",p="J64Bl2g14xIjQ0Vp6Xo0lPPu1oIdFx2G6yg6bVGgihA=";if("string"!=typeof o)throw Error("NEXT_PUBLIC_PRIVY_APP_ID needs to be defined");let u=(0,a.getGlobalPrivyAuthUrl)(),y="https://dashboard.privy.io";if(!y||"string"!=typeof y)if(i.YG||i.KV)throw Error("NEXT_PUBLIC_DASHBOARD_PRIVY_AUTH_URL must be defined");else y=u;let v=i.KV?"https://dashboard.privy.io":i.YG?"https://dashboard.staging.privy.io":y,h=i.KV?"privy.io":i.YG?"staging.privy.io":void 0;i.Nu||v||console.warn("No Privy dashboard URL found, some dashboard admin actions like reporting to Slack will not work.");let f="4df5e2316331463a9130964bd6078dfa";if("string"!=typeof f)if(i.KV||i.YG)throw Error("NEXT_PUBLIC_PRIVY_INFURA_ID must be set");else i.Nu||console.warn("Missing PRIVY_INFURA_ID - RPC calls may fail locally without this.");if("string"!=typeof d)if(i.KV||i.YG)throw Error("NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY must be set");else i.Nu||console.warn("Missing STRIPE_PUBLISHABLE_KEY - Stripe may fail without this.");if("string"!=typeof p)if(i.KV||i.YG)throw Error("NEXT_PUBLIC_DELEGATED_ACTIONS_TEE_PUBLIC_KEY must be set");else i.Nu||console.warn("Missing NEXT_PUBLIC_DELEGATED_ACTIONS_TEE_PUBLIC_KEY - delegated actions calls with fail locally without this.");let w=i.KV?"GTM-WV9MVTB3":void 0,m=Object.freeze({isTest:i.Nu,isProduction:i.KV,isStaging:i.YG,isDevelopment:i.yz,STANDARD_ENV:i.kR,PRIVY_APP_ID:o,MY_PRIVY_APP_ID:s,PRIVY_ENV:"production",GLOBAL_PRIVY_AUTH_URL:u,DASHBOARD_PRIVY_AUTH_URL:y,DASHBOARD_URL:v,ROOT_PRIVY_DOMAIN:h,PRIVY_INFURA_ID:f,GIT_COMMIT_SHA:c,VERCEL_GIT_COMMIT_REF:l,SPECIAL_EVENT_SIGNUP_ENABLED:!0,DEV_APP_USER_LIMIT:150,STRIPE_PUBLISHABLE_KEY:d,DELEGATED_ACTIONS_TEE_PUBLIC_KEY:p,GOOGLE_TAG_MANAGER_ID:w})},23105:(e,t,r)=>{"use strict";r.d(t,{$1:()=>I,$W:()=>V,AI:()=>G,Dz:()=>E,IV:()=>p,IW:()=>v,NB:()=>T,O:()=>P,QQ:()=>l,St:()=>U,Zn:()=>y,_o:()=>A,aV:()=>N,bE:()=>s,bz:()=>_,gc:()=>d,hH:()=>S,j:()=>g,j2:()=>M,jE:()=>x,jh:()=>b,p5:()=>h,q$:()=>K,ry:()=>u,u:()=>w,v$:()=>q});var a=r(69829),i=r(71246),n=r(80780);let o=e=>{var t;let r=new a.F(null==(t=e.response._data)?void 0:t.error);for(let t of["request","options","response"])Object.defineProperty(r,t,{get:()=>e[t]});for(let[t,a]of[["data","_data"],["status","status"],["statusCode","status"],["statusText","statusText"],["statusMessage","statusText"]])Object.defineProperty(r,t,{get:()=>e.response&&e.response[a]});throw r},s=async(e,t,r)=>await (0,i.OT)(e,{method:"POST",body:t,headers:r,timeout:9e3,credentials:"include",onResponseError:o}),c=async(e,t,r)=>await (0,i.OT)(e,{method:"PATCH",body:t,headers:r,timeout:9e3,credentials:"include",onResponseError:o});async function l(e){let{appId:t,appClientId:r,accessToken:a,address:i,chainType:n}=e;return(await s("/api/v1/embedded_wallets/init",{address:i,chain_type:n},V({appId:t,appClientId:r,accessToken:a}))).nonce}async function d(e){let{appId:t,appClientId:r,accessToken:a,data:i}=e;return await s("/api/v1/embedded_wallets",i,V({appId:t,appClientId:r,accessToken:a}))}async function p(e,t,r,a){return await s("/api/v1/embedded_wallets/add_solana",a,V({appId:e,appClientId:t,accessToken:r}))}async function u(e,t,r,a){return await s("/api/v1/embedded_wallets/add_ethereum",a,V({appId:e,appClientId:t,accessToken:r}))}async function y(e){let{appId:t,appClientId:r,accessToken:a,data:i}=e;return await s("/api/v1/embedded_wallets/add_wallet",i,V({appId:t,appClientId:r,accessToken:a}))}async function v(e){let{appId:t,appClientId:r,accessToken:a,data:i}=e;return await s("/api/v1/wallets/delegate",i,V({appId:t,appClientId:r,accessToken:a}))}async function h(e){let{appId:t,appClientId:r,accessToken:a,data:i}=e;return await c("/api/v1/embedded_wallets",{...i,chain_type:O(i.entropy_key_verifier)},V({appId:t,appClientId:r,accessToken:a}))}let f=async e=>{let{appId:t,appClientId:r,clientAnalyticsId:i,accessToken:n,fn:o}=e;try{return await o()}catch(e){if(!(e instanceof a.F)||e.response)throw e;return I({appId:t,appClientId:r,clientId:i,accessToken:n,eventName:"retry_fetch_share_no_response",payload:{error:e.message}}),await o()}};async function w(e){let{appId:t,appClientId:r,clientAnalyticsId:a,accessToken:i,entropyKey:n,entropyKeyVerifier:o,deviceId:s,mfaToken:c}=e;return await f({appId:t,appClientId:r,accessToken:i,clientAnalyticsId:a,fn:()=>m({appId:t,appClientId:r,accessToken:i,entropyKey:n,entropyKeyVerifier:o,deviceId:s,mfaToken:c})})}async function m(e){let{appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:n,deviceId:o,mfaToken:c}=e;return await s("/api/v1/embedded_wallets/".concat(encodeURIComponent(i),"/share"),{device_id:o,chain_type:O(n)},V({appId:t,appClientId:r,accessToken:a,mfaToken:c}))}async function _(e){let{appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:n,mfaToken:o}=e;return await s("/api/v1/embedded_wallets/".concat(encodeURIComponent(i),"/recovery/auth_share"),{chain_type:O(n)},V({appId:t,appClientId:r,accessToken:a,mfaToken:o}))}async function g(e){let{appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:n}=e;return await s("/api/v1/embedded_wallets/".concat(encodeURIComponent(i),"/recovery/key_material"),{chain_type:O(n)},V({appId:t,appClientId:r,accessToken:a}))}async function b(e){let{appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:n,recoveryKeyHash:o}=e;return await s("/api/v1/embedded_wallets/".concat(encodeURIComponent(i),"/recovery/shares"),{recovery_key_hash:o,chain_type:O(n)},V({appId:t,appClientId:r,accessToken:a}))}async function k(e){let{appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:n,deviceAuthShare:o,deviceId:c}=e;return await s("/api/v1/embedded_wallets/".concat(encodeURIComponent(i),"/recovery/device"),{device_id:c,device_auth_share:o,chain_type:O(n)},V({appId:t,appClientId:r,accessToken:a}))}async function E(e){let{userId:t,appId:r,appClientId:a,accessToken:i,entropyKey:o,entropyKeyVerifier:s,deviceAuthShare:c,deviceId:l}=e;try{return await k({appId:r,appClientId:a,accessToken:i,entropyKey:o,entropyKeyVerifier:s,deviceAuthShare:c,deviceId:l})}catch(e){if(e&&e instanceof Error&&(e.message.includes("abort")||e.message.includes("timeout"))){var d,p;let{share:e}=await m({mfaToken:null!=(p=null==(d=await n.A.get({appId:r,userId:t}))?void 0:d.token)?p:null,appId:r,appClientId:a,accessToken:i,entropyKey:o,entropyKeyVerifier:s,deviceId:l}).catch(()=>({share:null}));if(e)return{success:!0};return await k({appId:r,appClientId:a,accessToken:i,entropyKey:o,entropyKeyVerifier:s,deviceAuthShare:c,deviceId:l})}throw e}}function I(e){let{appId:t,appClientId:r,accessToken:a,clientId:i,eventName:n,payload:o,timestamp:c}=e;s("/api/v1/analytics_events",{event_name:n,client_id:i,payload:{...o||{},clientTimestamp:c?c.toISOString():new Date().toISOString()}},V({appId:t,appClientId:r,accessToken:a})).catch(()=>console.log("Unable to submit event. This is not an issue."))}async function P(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i}=e;return await s("/api/v1/mfa/totp/init",{action:"enroll"},V({appId:t,appClientId:r,accessToken:a,mfaToken:i}))}async function U(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i,phoneNumber:n}=e;return await s("/api/v1/mfa/passwordless_sms/init",{phoneNumber:n,action:"enroll"},V({appId:t,appClientId:r,accessToken:a,mfaToken:i}))}async function K(e){let{appId:t,appClientId:r,accessToken:a,code:i}=e;return await s("/api/v1/mfa/totp/enroll",{code:i},V({appId:t,appClientId:r,accessToken:a}))}async function T(e){let{appId:t,appClientId:r,accessToken:a,credentialIds:i,mfaToken:n,removeForLogin:o}=e;return await s("/api/v1/mfa/passkeys/enrollment",{credential_ids:i,remove_for_login:o},V({appId:t,appClientId:r,accessToken:a,mfaToken:n}))}async function A(e){let{appId:t,appClientId:r,accessToken:a,code:i,phoneNumber:n}=e;return await s("/api/v1/mfa/passwordless_sms/enroll",{phoneNumber:n,code:i},V({appId:t,appClientId:r,accessToken:a}))}async function x(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i}=e;return await s("/api/v1/mfa/passwordless_sms/unenroll",{},V({appId:t,appClientId:r,accessToken:a,mfaToken:i}))}async function S(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i}=e;return await s("/api/v1/mfa/totp/unenroll",{},V({appId:t,appClientId:r,accessToken:a,mfaToken:i}))}async function C(e){let{appId:t,appClientId:r,accessToken:a,code:i}=e;return await s("/api/v1/mfa/passwordless_sms/verify",{code:i},V({appId:t,appClientId:r,accessToken:a}))}async function F(e){let{appId:t,appClientId:r,accessToken:a,code:i}=e;return await s("/api/v1/mfa/totp/verify",{code:i},V({appId:t,appClientId:r,accessToken:a}))}async function R(e){let{appId:t,appClientId:r,accessToken:a,authenticatorResponse:i,relyingParty:n}=e;return await s("/api/v1/mfa/passkeys/verify",{authenticator_response:i,relying_party:n},V({appId:t,appClientId:r,accessToken:a}))}async function M(e){let{appId:t,appClientId:r,accessToken:a,code:i,method:n,relyingParty:o}=e;switch(n){case"sms":return await C({appId:t,appClientId:r,accessToken:a,code:i});case"totp":return await F({appId:t,appClientId:r,accessToken:a,code:i});case"passkey":return await R({appId:t,appClientId:r,accessToken:a,relyingParty:o,authenticatorResponse:i});default:throw Error("Unknown mfa method: ".concat(n))}}async function N(e){let{appId:t,appClientId:r,signerPublicKey:a,auth:i}=e;return await s("/api/v1/farcaster/signer/init",{ed25519_public_key:a},V({appId:t,appClientId:r,accessToken:i.accessToken,mfaToken:i.mfaToken}))}async function q(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i,credentialId:n,removeAsMfa:o}=e;return await s("/api/v1/passkeys/unlink",{credential_id:n,remove_as_mfa:o},V({appId:t,appClientId:r,accessToken:a,mfaToken:i}))}async function G(e){let{appId:t,appClientId:r,accessToken:a,data:i}=e;return await s("/api/v1/recovery/configuration_icloud",{client_type:i.client_type},V({appId:t,appClientId:r,accessToken:a}))}function V(e){let{appId:t,appClientId:r,accessToken:a,mfaToken:i,headers:n}=e,o=new Headers(n);return o.set("privy-app-id",t),o.set("authorization","Bearer ".concat(a)),r&&o.set("privy-client-id",r),i&&o.set("privy-mfa-token",i),o}let L={"ethereum-address-verifier":"ethereum","solana-address-verifier":"solana",p256:"p256"},O=e=>L[e]},27953:(e,t,r)=>{"use strict";r.d(t,{h6:()=>h,kL:()=>y,io:()=>l,jt:()=>U.A,Zv:()=>K.A,uP:()=>I,JG:()=>_,_U:()=>x});var a=r(66875),i=r(12192),n=r(23105),o=r(72758),s=r(96827),c=r(63892);async function l(e){let t,{appId:r,appClientId:l,userId:d,accessToken:p,clientType:u,recoveryPassword:y,recoveryMethod:v,recoveryAccessToken:h,recoveryPin:f,recoveryKey:w,recoverySecretOverride:m,iCloudRecordNameOverride:_,createWalletEvent:g,existingEntropy:b}=e,k=[new Uint8Array([]),new Uint8Array([])],E=[new Uint8Array([]),new Uint8Array([])];b?({deviceShares:k}=await (0,i.MR)(b),t=(0,i.Ay)({entropy:b,walletIndex:0})):{deviceShares:k,recoveryShares:E,wallet:t}=await (0,i.sr)();let[I,P]=k,U=await n.QQ({appId:r,appClientId:l,accessToken:p,address:t.address,chainType:"ethereum"}),K=(0,i.t5)(window.location.host,window.location.origin,t.address,U),T=await t.signMessage({message:K}),A=(0,i.hE)();if(b)await n.ry(r,l,p,{message:K,signature:T,device_auth_share:a.K3.encode(P),device_id:A});else{let[e,o]=E,{encryptionKey:b,walletRecoveryOutput:k,recoveryType:I}=await (0,s.z)({appId:r,appClientId:l,userId:d,accessToken:p,walletAddress:t.address,clientType:u,recoveryMethod:v,recoveryPassword:y,recoveryPin:f,recoveryKey:w,recoveryAccessToken:h,recoverySecretOverride:m,iCloudRecordNameOverride:_,createWalletEvent:g}),[U,x]=await Promise.all([(0,i.EN)(b),(0,i.vb)(e,b)]),S=await (0,c.qz)(k);await n.gc({appId:r,appClientId:l,accessToken:p,data:{entropy_key:t.address,entropy_key_verifier:"ethereum-address-verifier",chain_type:"ethereum",message:K,signature:T,device_id:A,device_auth_share:a.K3.encode(P),recovery_auth_share:a.K3.encode(o),encrypted_recovery_share:a.K3.encode(x.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(x.encryptedShareIV),recovery_type:I,recovery_key_hash:a.K3.encode(U),imported:!1,...S}})}return await o.A.set({appId:r,userId:d,address:t.address},{share:a.K3.encode(I),deviceId:A}),{wallet:t,walletIndex:0}}var d=r(78007),p=r.n(d),u=r(36001).Buffer;async function y(e){let t,r,{appId:s,appClientId:l,userId:d,accessToken:y,existingEntropy:v}=e,h=[new Uint8Array([]),new Uint8Array([])],f=[new Uint8Array([]),new Uint8Array([])];v?({deviceShares:h}=await (0,i.MR)(v),t=(0,i.kG)({entropy:v,index:0}),r=v):{deviceShares:h,recoveryShares:f,keypair:t,entropy:r}=await (0,i.IV)(256);let w=t.publicKey.toBase58(),[m,_]=h,g=await n.QQ({appId:s,appClientId:l,accessToken:y,address:w,chainType:"solana"}),b=(0,i.zT)(window.location.host,window.location.origin,w,g),k=p().sign.detached(u.from(b),t.secretKey),E=a.K3.encode(u.from(k)),I=(0,i.hE)();if(v)await n.IV(s,l,y,{message:b,signature:E,device_id:I,device_auth_share:a.K3.encode(_)});else{let{encryptionKey:e,walletRecoveryOutput:t}=await (0,c.cq)({recoveryType:"privy_generated_recovery_key"}),{recovery_key:r}=await (0,c.qz)(t),[o,d]=f,[p,u]=await Promise.all([(0,i.EN)(e),(0,i.vb)(o,e)]);await n.gc({appId:s,appClientId:l,accessToken:y,data:{entropy_key:w,entropy_key_verifier:"solana-address-verifier",chain_type:"solana",message:b,signature:E,device_id:I,device_auth_share:a.K3.encode(_),recovery_auth_share:a.K3.encode(d),encrypted_recovery_share:a.K3.encode(u.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(u.encryptedShareIV),recovery_type:"privy_generated_recovery_key",recovery_key_hash:a.K3.encode(p),recovery_key:r,imported:!1}})}return await o.A.set({appId:s,userId:d,address:w},{share:a.K3.encode(m),deviceId:I}),{entropyType:"hd-entropy",chainType:"solana",wallet:{keypair:t,address:w},walletIndex:0,entropy:r}}var v=r(39972);async function h(e){let{appId:t,appClientId:r,accessToken:a,hdWalletIndex:o,entropy:s}=e;if(o<=0)throw new v.Pi("invalid_request_arguments","Failed to create additional wallet: invalid wallet index");let c=(0,i.Ay)({entropy:s,walletIndex:o}),l=await n.QQ({appId:t,appClientId:r,accessToken:a,address:c.address,chainType:"ethereum"}),d=(0,i.t5)(window.location.host,window.location.origin,c.address,l),p=await c.signMessage({message:d});return await n.Zn({appId:t,appClientId:r,accessToken:a,data:{message:d,signature:p,hd_node_index:o,chain_type:"ethereum"}}),c}var f=r(90093),w=r(86068),m=r(88767);async function _(e){let{cachedWalletData:t,appId:r,appClientId:a,clientAnalyticsId:n,userId:o,hdWalletIndex:s,chainType:c,entropyId:l,entropyIdVerifier:d,accessToken:p,mfaCode:u,mfaMethod:y,relyingParty:h,verificationKeys:_,hasSetMfaToken:g,createWalletEvent:b}=e,{entropy:k,entropyType:E}=await (0,m.A)({cache:t,appId:r,appClientId:a,clientAnalyticsId:n,userId:o,entropyId:l,entropyIdVerifier:d,accessToken:p,mfaCode:u,mfaMethod:y,relyingParty:h,verificationKeys:_,hasSetMfaToken:g,createWalletEvent:b});if(t&&k===t.entropy&&t.entropyId===l&&t.chainType===c&&t.walletIndex===s)return t;if("private-key"===E&&"ethereum"===c)return{entropy:k,entropyType:E,entropyId:l,entropyIdVerifier:d,chainType:"ethereum",wallet:(0,i.st)({entropy:k})};if("private-key"===E&&"solana"===c){let e=(0,i.Wi)({entropy:k});return{entropy:k,entropyType:E,entropyId:l,entropyIdVerifier:d,chainType:c,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===E&&"ethereum"===c)return{entropy:k,entropyType:E,entropyId:l,entropyIdVerifier:d,chainType:c,walletIndex:s,wallet:(0,i.Ay)({entropy:k,walletIndex:s})};if("hd-entropy"===E&&"solana"===c){let e=(0,i.kG)({entropy:k,index:s});return{entropy:k,entropyType:E,entropyId:l,entropyIdVerifier:d,chainType:c,walletIndex:s,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===E&&"bitcoin-segwit"===c)return{entropyType:E,entropy:k,entropyId:l,entropyIdVerifier:d,chainType:c,walletIndex:s,wallet:(0,f.E)({entropy:k,index:s,pathType:"segwit"})};if("hd-entropy"===E&&"bitcoin-taproot"===c)return{entropyType:E,entropy:k,entropyId:l,entropyIdVerifier:d,chainType:c,walletIndex:s,wallet:(0,f.E)({entropy:k,index:s,pathType:"taproot"})};if("private-key"===E&&"p256"===c)return{entropyType:E,entropy:k,entropyId:l,entropyIdVerifier:d,chainType:c,wallet:await (0,w.a)({entropy:k})};throw new v.Pi("invalid_request_arguments","Failed to initialize ".concat(c," wallet at index ").concat(s))}var g=r(85432),b=r(39968),k=r(80015),E=r(65563);async function I(e){let t,r,s,{appId:c,appClientId:l,createWalletEvent:d,userId:p,accessToken:u,verificationKeys:y,hasSetMfaToken:h,clientType:f,entropyId:m,entropyIdVerifier:_,recoveryPassword:I,recoveryKey:U,mfaCode:K,mfaMethod:T,relyingParty:A,recoveryAccessToken:x,recoverySecretOverride:S}=e;if("ethereum-address-verifier"!==_||(0,i.qi)(m)){if("solana-address-verifier"===_&&!(0,i.Zf)(m))throw new v.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address")}else throw new v.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address");if(void 0!==I&&!(0,i.jt)(I))throw new v.Pi("invalid_request_arguments","Failed to recover wallet: invalid recovery pin");let C=await (0,E.X)({appId:c,appClientId:l,userId:p,accessToken:u,mfaMethod:T,mfaCode:K,relyingParty:A,verificationKeys:y,hasSetMfaToken:h,createWalletEvent:d}),{recovery_type:F,recovery_key_derivation_salt:R,recovery_code:M,recovery_key:N,file_id:q,icloud_record_name:G}=await n.j({appId:c,appClientId:l,accessToken:u,entropyKey:m,entropyKeyVerifier:_});if("icloud_recovery_secret"!==F&&S)throw new v.Pi("invalid_request_arguments","Failed to recover wallet: recovery secret override is only supported for iCloud recovery");if("user_passcode_derived_recovery_key"===F){if(!I)throw new v.Pi("error","Failed to recover wallet: user passcode required and none found");if(!R)throw new v.Pi("error","Failed to recover wallet: cannot retrieve salt for user-supplied passcode derived wallet");t=await (0,i.Ud)(I,a.K3.decode(R))}else if("privy_passcode_derived_recovery_key"===F){if(!R)throw new v.Pi("error","Failed to recover wallet: cannot retrieve salt for Privy-supplied passcode derived wallet");if(!M)throw new v.Pi("error","Failed to recover wallet: cannot retrieve Privy-supplied passcode");t=await (0,i.Ud)(M,a.K3.decode(R))}else if("privy_generated_recovery_key"===F){if(!N)throw new v.Pi("error","Failed to recover wallet: cannot retrieve Privy-generated recovery key");t=await (0,i.kS)(a.K3.decode(N))}else if("google_drive_recovery_secret"===F){let e;if(!q)throw new v.Pi("error","Failed to recover wallet: cannot retrieve fileId for Google Drive recovery secret derived recovery key");if(!x)throw new v.Pi("error","Failed to recover wallet: missing recovery auth access token");try{e=await (0,b.lT)(x,{fileId:q})}catch(e){throw new v.Pi("error","Failed to recover wallet: failed to read recovery secret from Google Drive")}if(!e)throw new v.Pi("error","Failed to recover wallet: missing recovery secret from Google Drive");t=await (0,i.kS)(a.K3.decode(e))}else if("icloud_recovery_secret"===F){let e;if(S)e=S;else{if(!G)throw new v.Pi("error","Failed to recover wallet: cannot retrieve iCloud record name for iCloud recovery secret derived recovery key");if(!x)throw new v.Pi("error","Failed to recover wallet: missing recovery auth access token");try{let{cloudKitContainerIdentifier:t,cloudKitEnvironment:r,cloudKitApiToken:a}=await (0,k.hf)(c,l,u,f);e=await (0,k.WT)({ckWebAuthToken:x,recordName:G,entropyId:m,cloudKitContainerIdentifier:t,cloudKitEnvironment:r,cloudKitApiToken:a,createWalletEvent:(e,t)=>d(e,{...t,entropyIdVerifier:_})})}catch(e){if(e instanceof v.Pi)throw e;throw new v.Pi("unknown_icloud_recovery_error","Failed to recover wallet: unknown issue reading recovery secret from iCloud")}if(!e)throw new v.Pi("error","Failed to recover wallet: missing recovery secret from iCloud")}t=await (0,i.kS)(a.K3.decode(e))}else if("recovery_encryption_key"===F){if(!U)throw new v.Pi("error","Failed to recover wallet: missing recovery key");t=await (0,i.kS)(a.K3.decode(U))}if(!t)throw new v.Pi("error","Failed to recover wallet recovery key");let V=await (0,i.EN)(t),{recoveryAuthShare:L,encryptedRecoveryShare:O,encryptedRecoveryShareIV:B,imported:D}=await P({appId:c,appClientId:l,accessToken:u,entropyId:m,entropyIdVerifier:_,recoveryKeyHash:a.K3.encode(V),mfaToken:C}),j=await (0,i.nz)(a.K3.decode(O),a.K3.decode(B),t);if("ethereum-address-verifier"===_&&D){let{reconstructedWallet:e,reconstructedPrivateKey:t}=await (0,i.Pp)({shares:[j,a.K3.decode(L)],expectedAddress:m});r={entropyId:m,entropyIdVerifier:_,chainType:"ethereum",entropyType:"private-key",wallet:e,entropy:t},s=t}else if("ethereum-address-verifier"===_){let{entropy:e,wallet:t}=await (0,i.p$)({shares:[j,a.K3.decode(L)],primaryAddress:m,walletIndex:0});s=(r={entropyId:m,entropyIdVerifier:_,chainType:"ethereum",entropyType:"hd-entropy",wallet:t,entropy:e,walletIndex:0}).entropy}else if("solana-address-verifier"===_&&D){let{reconstructedKeypair:e,reconstructedPrivateKey:t}=await (0,i.IX)({shares:[j,a.K3.decode(L)],expectedAddress:m});r={chainType:"solana",entropyType:"private-key",entropyId:m,entropyIdVerifier:_,wallet:{keypair:e,address:e.publicKey.toBase58()},entropy:t},s=t}else if("solana-address-verifier"===_){let{reconstructedKeypair:e,reconstructedEntropy:t}=await (0,i.M4)({shares:[j,a.K3.decode(L)],expectedPublicKey:m,index:0});r={chainType:"solana",entropyType:"hd-entropy",entropyId:m,entropyIdVerifier:_,wallet:{keypair:e,address:e.publicKey.toBase58()},walletIndex:0,entropy:t},s=t}else if("p256"===_){let e=await (0,g.k)([j,a.K3.decode(L)]),t=await (0,w.a)({entropy:e});if(t.publicKey!==m)throw Error("Failed to reconstruct the expected public key from Shamir shares.");r={chainType:"p256",entropyType:"private-key",entropyId:m,entropyIdVerifier:_,wallet:t,entropy:e},s=e}else throw new v.Pi("error","Failed to recover wallet: entropyIdVerifier ".concat(_," not supported"));let z=(0,i.hE)(),[W,Y]=await (0,i.uY)(s),H=a.K3.encode(Y);return await n.Dz({userId:p,appId:c,appClientId:l,accessToken:u,entropyKey:m,entropyKeyVerifier:_,deviceId:z,deviceAuthShare:H}),await o.A.set({appId:c,userId:p,address:m},{share:a.K3.encode(W),deviceId:z}),r}async function P(e){let{appId:t,appClientId:r,accessToken:a,entropyId:i,entropyIdVerifier:o,recoveryKeyHash:s,mfaToken:c}=e;try{let[e,l]=await Promise.all([n.bz({appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:o,mfaToken:c}),n.jh({appId:t,appClientId:r,accessToken:a,entropyKey:i,entropyKeyVerifier:o,recoveryKeyHash:s})]);return{recoveryAuthShare:e.share,encryptedRecoveryShare:l.encrypted_recovery_share,encryptedRecoveryShareIV:l.encrypted_recovery_share_iv,imported:l.imported}}catch(e){var l;if((null==(l=e.response)?void 0:l.status)===400)throw new v.Pi("invalid_recovery_pin","Failed to recover wallet: invalid recovery pin");if((0,v.$J)(e))throw new v.Pi("missing_or_invalid_mfa","MFA verification failed");throw new v.Pi("error","Failed to recover wallet: ".concat(e instanceof Error?e.message:"unknown error"))}}var U=r(65276),K=r(7537),T=r(30604),A=r(36001).Buffer;async function x(e){let{appId:t,appClientId:r,userId:s,accessToken:l,clientType:d,entropy:p,entropyId:u,entropyIdVerifier:y,recoveryOptions:h,createWalletEvent:f}=e,w=T.Z[h.recoveryMethod];h.existingRecoveryMethod&&function(e){let{currentRecoveryMethod:t,upgradeToRecoveryMethod:r}=e;switch(t){case"privy_generated_recovery_key":case"user_passcode_derived_recovery_key":case"privy_passcode_derived_recovery_key":case"recovery_encryption_key":return;case"icloud_recovery_secret":case"google_drive_recovery_secret":if(t===r)throw Error("Cannot upgrade to the existing cloud platform");return;default:var a=t;throw Error("Expected never got ".concat(a))}}({currentRecoveryMethod:T.Z[h.existingRecoveryMethod],upgradeToRecoveryMethod:w});let m=(0,c.Zw)({recoveryType:w,appId:t,appClientId:r,userId:s,entropyId:u,clientType:d,accessToken:l,createWalletEvent:f,recoveryPassword:"user-passcode"===h.recoveryMethod?h.recoveryPassword:void 0,recoveryKey:"recovery-encryption-key"===h.recoveryMethod?h.recoveryKey:void 0,recoveryAccessToken:"google-drive"===h.recoveryMethod||"icloud"===h.recoveryMethod?h.recoveryAccessToken:void 0,recoverySecretOverride:"icloud-native"===h.recoveryMethod?h.recoverySecretOverride:void 0,iCloudRecordNameOverride:"icloud-native"===h.recoveryMethod?h.iCloudRecordNameOverride:void 0}),_=await o.A.get({appId:t,userId:s,address:u});if(!_)throw new v.Pi("wallet_not_on_device","Failed to initialize wallet: wallet with address '".concat(u,"' not loaded on this device"));let[g,b]=await Promise.all([(0,i.uY)(p),(0,i.uY)(p)]),[k,E]=g,[I,P]=b;await S({shares:[I,P],entropyId:u,entropyIdVerifier:y});let[U,{encryptionKey:K,walletRecoveryOutput:A}]=await Promise.all([n.QQ({appId:t,appClientId:r,accessToken:l,address:u,chainType:"ethereum-address-verifier"===y?"ethereum":"solana"}),(0,c.cq)(m)]),[x,F]=await Promise.all([(0,i.EN)(K),(0,i.vb)(I,K)]),[R,{message:M,signature:N}]=await Promise.all([(0,c.qz)(A),C({nonce:U,entropy:p,entropyId:u,entropyIdVerifier:y})]);return await n.p5({appId:t,appClientId:r,accessToken:l,data:{entropy_key:u,entropy_key_verifier:y,message:M,signature:N,device_id:_.deviceId,device_auth_share:a.K3.encode(E),recovery_type:w,recovery_auth_share:a.K3.encode(P),encrypted_recovery_share:a.K3.encode(F.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(F.encryptedShareIV),recovery_key_hash:a.K3.encode(x),...R}}),await o.A.set({appId:t,userId:s,address:u},{share:a.K3.encode(k),deviceId:_.deviceId}),{entropy:p,entropyId:u,entropyIdVerifier:y,entropyType:"hd-entropy"}}async function S(e){let{entropyIdVerifier:t,shares:r,entropyId:a}=e;"solana-address-verifier"===t?await (0,i.M4)({shares:r,expectedPublicKey:a,index:0}):await (0,i.p$)({shares:r,primaryAddress:a,walletIndex:0})}async function C(e){let{nonce:t,entropy:r,entropyId:n,entropyIdVerifier:o}=e;if("solana-address-verifier"===o){let e=(0,i.zT)(window.location.host,window.location.origin,n,t),o=(0,i.kG)({entropy:r,index:0}),s=p().sign.detached(A.from(e),o.secretKey);return{message:e,signature:a.K3.encode(s)}}{let e=(0,i.t5)(window.location.host,window.location.origin,n,t),a=(0,i.Ay)({entropy:r,walletIndex:0}),o=await a.signMessage({message:e});return{message:e,signature:o}}}},30604:(e,t,r)=>{"use strict";r.d(t,{Z:()=>a});let a={"recovery-encryption-key":"recovery_encryption_key","user-passcode":"user_passcode_derived_recovery_key",privy:"privy_generated_recovery_key","google-drive":"google_drive_recovery_secret",icloud:"icloud_recovery_secret","icloud-native":"icloud_recovery_secret"}},30666:(e,t,r)=>{"use strict";r.d(t,{j:()=>a});let a=({origin:e,path:t,query:r={},hash:a={}})=>{let i=new URL(t,e.endsWith("/")?e:`${e}/`);for(let[e,t]of Object.entries(r))void 0!==t&&i.searchParams.set(e,t);let n=Object.entries(a);if(n.length>0){let e=new URLSearchParams;for(let[t,r]of n)void 0!==r&&e.append(t,r);i.hash=e.toString()}return i.href}},31461:(e,t,r)=>{"use strict";r.d(t,{P:()=>i});var a=r(79751);let i=()=>({addMessageListener(e){(0,a.k3)(window)?document.addEventListener("message",e):window.addEventListener("message",e)},removeMessageListener(e){(0,a.k3)(window)?document.removeEventListener("message",e):window.removeEventListener("message",e)},sendMessage(e){var t,r;null==(r=window.ReactNativeWebView)||null==(t=r.postMessage)||t.call(r,e)}})},32535:(e,t,r)=>{"use strict";r.d(t,{b:()=>s});var a=r(51193),i=r(38744),n=r(66875),o=r(36001).Buffer;let s=async e=>{let{message:t,privateKey:r}=e,o=(0,i.sc)(n.K3.decode(t)),s=c(r),l=a.s9.sign(o,s);return n.K3.encode(l.toDERRawBytes())},c=e=>{let t=o.from(e),r=t.indexOf(o.from([4,32]));if(-1===r)throw Error("Invalid wallet authorization private key");let i=t.subarray(r+2,r+34);return a.s9.utils.normPrivateKeyToScalar(i)}},39968:(e,t,r)=>{"use strict";r.d(t,{Vz:()=>s,lT:()=>c,w5:()=>o});var a=r(66875),i=r(5676),n=r(12192);async function o(e){let{appId:t,userId:r,entropyId:i}=e,o=await (0,n.YZ)(i),s=a.K3.encode(o);return"privy-wallet-".concat(t,"-").concat(r,"-").concat(s,".txt")}async function s(e,t){let{recoverySecret:r,filename:a}=t,n="recovery-secret-boundary",o="\r\n--".concat(n,"\r\n"),s=o+"Content-Type: application/json; charset=UTF-8\r\n\r\n"+JSON.stringify({name:a,mimeType:"text/plain",parents:["appDataFolder"]})+o+"Content-Type: text/plain\r\n\r\n"+r+"\r\n--".concat(n,"--");return(await i.A.post("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",s,{headers:{"Content-Type":'multipart/related; boundary="'.concat(n,'"'),Authorization:"Bearer ".concat(e)}})).data.id}async function c(e,t){let{fileId:r}=t;return(await i.A.get("https://www.googleapis.com/drive/v3/files/".concat(r),{headers:{Authorization:"Bearer ".concat(e)},params:{alt:"media"},responseType:"text"})).data}},39972:(e,t,r)=>{"use strict";r.d(t,{$J:()=>l,Pi:()=>n,RO:()=>o,dS:()=>c,xR:()=>s,z6:()=>i});let a=["error","invalid_request_arguments","wallet_not_on_device","hd_wallet_required","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","twilio_verification_failed","no_icloud_record_found","multiple_icloud_records_found","unknown_icloud_recovery_error","unknown_icloud_storage_error"],i="error";class n extends Error{constructor(e,t){super(t),this.type=e}}class o extends n{convert(){return new n(this.type,this.message)}constructor(e,t,r){super(e,t),this.type=e,this.eventInfo=r}}function s(e){let t=e.type;return"string"==typeof t&&a.includes(t)}function c(e){return s(e)&&!!e.convert}function l(e){var t;let r=null==(t=e.data)?void 0:t.code;return"missing_or_invalid_mfa"===r||"expired_or_invalid_mfa_token"===r}},41853:(e,t,r)=>{"use strict";r.d(t,{d:()=>n});var a=r(25162),i=r(78162);async function n(e,t,r){if(!e)return console.error("No access token provided."),null;try{var a;let i=await o(e,r,t),n=(a=i.payload.sub,"string"==typeof a&&/^did:privy:.+/.test(a)?a.replace(/^did:privy:/,""):null);if(!n)return console.error("Unable to decode user ID. Audience claim:",i.payload.aud),null;if(!i.payload.aud)return console.error("Access token does not contain an audience claim."),null;return console.debug("Successfully verified access token."),{userId:n,appId:r}}catch(e){return console.error(e),null}}async function o(e,t,r){let n={typ:"JWT",algorithms:[i.oG],issuer:i.GR},o=(0,i.Io)(e);o||(n.audience=t);let s=await Promise.allSettled(r.map(async r=>{let s=await a.jU(r,i.oG),c=await a.Vv(e,s,n);if(o&&c.payload[i.cf]!==t)throw Error("Access token does not have correct appId");return c})),c=s.find(e=>"fulfilled"===e.status);if(!c)throw s[0].reason;return c.value}},44009:(e,t,r)=>{"use strict";r.d(t,{n:()=>n,r:()=>i});var a=r(79751);class i{async getItem(e){let t=this.cacheStorage.getItem(e);if(null!==t)return t;try{let{value:t}=await this.makeCallToApp({event:"app:secure-storage:get",data:{key:e}});return t&&this.cacheStorage.setItem(e,t),t}catch(e){return null}}async setItem(e,t){try{let{success:r}=await this.makeCallToApp({event:"app:secure-storage:set",data:{key:e,value:t}});r&&this.cacheStorage.setItem(e,t)}catch(e){return}}async removeItem(e){this.cacheStorage.removeItem(e);try{await this.makeCallToApp({event:"app:secure-storage:remove",data:{key:e}})}catch(e){return}}async makeCallToApp(e){return await new Promise((t,r)=>{let a=Math.random().toString(36).slice(2);this.appMessaging.sendMessage(JSON.stringify({...e,id:a}));let i=r=>{let n=this.parseMessageEventToResponse(r);n.event===e.event&&n.id===a&&(this.appMessaging.removeMessageListener(i),t(n.data))};this.appMessaging.addMessageListener(i),setTimeout(()=>{this.appMessaging.removeMessageListener(i),r(Error("Timed out waiting for the application to respond"))},200)})}parseMessageEventToResponse(e){return"string"==typeof e.data?JSON.parse(e.data):e.data}constructor(e,t){this.cacheStorage=e,this.appMessaging=t}}let n=()=>{try{var e,t;if(!(0,a.l_)(window))return!1;let r=null==(t=window.ReactNativeWebView)||null==(e=t.injectedObjectJson)?void 0:e.call(t);if(!r)return!1;let i=JSON.parse(r);if("object"!=typeof i||null===i)return!1;return"shouldUseAppBackedStorage"in i&&!0===i.shouldUseAppBackedStorage}catch(e){return console.warn("Unable to determine if app-backed storage is supported",e),!1}}},56496:(e,t,r)=>{"use strict";r(36001).Buffer;async function a(){return await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"])}t.CD=a;"undefined"==typeof crypto&&(globalThis.crypto=r(18842).webcrypto)},57175:()=>{},59200:(e,t,r)=>{"use strict";r.d(t,{KV:()=>c,Nu:()=>s,YG:()=>l,kR:()=>d,yz:()=>o});var a=r(15093);let i=["development","test","production","staging"],n="production";if(!n||!i.includes(n))throw Error('Invalid NEXT_PUBLIC_PRIVY_ENV: "'.concat(n,'". Must be one of: ').concat(i.join(", ")));let o=!1,s=!1,c=!0,l=!1,d=function(e){switch(e){case"production":return"prod";case"staging":return"stage";case"development":return"dev";case"test":return"test";default:return(0,a.n)(e)}}(n)},60439:(e,t,r)=>{"use strict";r.d(t,{c:()=>a});let a=(0,r(78273).x)({id:143,name:"Monad",blockTime:400,nativeCurrency:{name:"Monad",symbol:"MON",decimals:18},rpcUrls:{default:{http:["https://rpc.monad.xyz"]},privy:{http:["https://monad-mainnet.rpc.privy.systems"]},privyInternal:{http:["https://bitter-dimensional-orb.monad-mainnet.quiknode.pro/1461dbb58377f459dee7e676b2f6b813b69ff55a"]}},blockExplorers:{default:{name:"Monadscan",url:"https://mainnet-beta.monvision.io"}},contracts:{multicall3:{address:"0xcA11bde05977b3631167028862bE2a173976CA11",blockCreated:9248132}},testnet:!1})},62645:(e,t,r)=>{"use strict";r.d(t,{m:()=>i});var a=r(36001).Buffer;let i=async e=>{let t=await crypto.subtle.importKey("pkcs8",e,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),r=await crypto.subtle.exportKey("jwk",t);delete r.d,r.key_ops=["verify"];let i=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]);return a.from(await crypto.subtle.exportKey("spki",i))}},63892:(e,t,r)=>{"use strict";r.d(t,{Zw:()=>c,cq:()=>l,qz:()=>d});var a=r(66875),i=r(12192),n=r(39972),o=r(39968),s=r(80015);function c(e){let{recoveryType:t,appId:r,appClientId:a,userId:o,entropyId:s,accessToken:c,clientType:l,recoveryPassword:d,recoveryKey:p,recoveryAccessToken:u,recoverySecretOverride:y,iCloudRecordNameOverride:v,createWalletEvent:h}=e;if("user_passcode_derived_recovery_key"===t){if(!d||!(0,i.jt)(d))throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing or invalid recovery password");if(u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for user recovery secret protected wallets.");return{recoveryType:t,recoveryPassword:d}}if("privy_generated_recovery_key"===t){if(d)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for privy generated recovery key wallets.");if(u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for privy generated recovery key wallets.");return{recoveryType:t}}if("google_drive_recovery_secret"===t){if(!u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token");if(d)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for google drive recovery secret protected wallets.");return{recoveryType:t,recoveryAccessToken:u,appId:r,userId:o,entropyId:s}}if("icloud_recovery_secret"===t){if(!(u||y&&v))throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token or value overrides");if(d)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for iCloud recovery secret protected wallets.");if(!["web","expo-ios"].includes(l))throw new n.Pi("invalid_request_arguments","Failed to create wallet: client type ".concat(l," is not supported for iCloud recovery"));return{recoveryType:t,recoveryAccessToken:null!=u?u:null,appId:r,appClientId:a,userId:o,entropyId:s,customerAccessToken:c,clientType:l,recoverySecretOverride:null!=y?y:null,iCloudRecordNameOverride:null!=v?v:null,createWalletEvent:h}}if("recovery_encryption_key"===t){if(!p)throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing or invalid recovery key");return{recoveryType:t,recoveryKey:p}}else throw new n.Pi("invalid_request_arguments","Failed to create wallet: unknown recovery type: ".concat(t))}async function l(e){let{recoveryType:t}=e;if("user_passcode_derived_recovery_key"===t){let{recoveryPassword:r}=e,a=(0,i.s5)();return{encryptionKey:await (0,i.Ud)(r,a),walletRecoveryOutput:{recoveryType:t,recoveryKeyDerivationSalt:a}}}if("privy_generated_recovery_key"===t){let e=await (0,i.CI)();return{encryptionKey:e,walletRecoveryOutput:{recoveryType:t,encryptionKey:e}}}if("google_drive_recovery_secret"===t){let r,{recoveryAccessToken:s}=e,c=await (0,i.CI)(),l=a.K3.encode(await (0,i.WQ)(c)),d=await (0,o.w5)({appId:e.appId,userId:e.userId,entropyId:e.entropyId});try{r=await (0,o.Vz)(s,{recoverySecret:l,filename:d})}catch(t){let e=t instanceof Error?t.message:"Provider error";throw new n.Pi("error","Failed to write recovery secret to Google Drive: ".concat(e))}return{encryptionKey:c,walletRecoveryOutput:{recoveryType:t,filename:d,fileId:r}}}if("icloud_recovery_secret"===t){let r,{recoveryAccessToken:o,entropyId:c,appId:l,appClientId:d,userId:p,customerAccessToken:u,clientType:y,recoverySecretOverride:v,iCloudRecordNameOverride:h}=e;if(v&&!h||!v&&h)throw new n.Pi("invalid_request_arguments","Failed to create wallet: both recovery secret and iCloud record name must be provided if one is provided.");if(v&&h)return{encryptionKey:await (0,i.kS)(a.K3.decode(v)),walletRecoveryOutput:{recoveryType:t,recordName:h}};if(!o)throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token for iCloud recovery");let f=await (0,i.CI)(),w=a.K3.encode(await (0,i.WQ)(f));try{let{cloudKitContainerIdentifier:e,cloudKitEnvironment:t,cloudKitApiToken:a}=await (0,s.hf)(l,d,u,y);r=await (0,s.yt)({ckWebAuthToken:o,recoverySecretToStore:w,entropyId:c,appId:l,userId:p,cloudKitContainerIdentifier:e,cloudKitEnvironment:t,cloudKitApiToken:a})}catch(r){if((0,n.dS)(r))throw e.createWalletEvent(r.eventInfo.eventName,r.eventInfo.payload),r.convert();let t=r instanceof Error?r.message:"Provider error";throw new n.Pi("error","Failed to write recovery secret to iCloud: ".concat(t))}return{encryptionKey:f,walletRecoveryOutput:{recoveryType:t,recordName:r}}}if("recovery_encryption_key"===t){let{recoveryKey:r}=e;try{let e=await (0,i.kS)(a.K3.decode(r));return{encryptionKey:e,walletRecoveryOutput:{recoveryType:t,encryptionKey:e}}}catch(t){let e=t instanceof Error?t.message:"invalid key";throw new n.Pi("error","Unable to decode and import recovery key: ".concat(e))}}else throw Error("Unknown recovery type.")}async function d(e){let{recoveryType:t}=e;if("user_passcode_derived_recovery_key"===t){let{recoveryKeyDerivationSalt:t}=e;return{recovery_key_derivation_salt:a.K3.encode(t)}}if("privy_generated_recovery_key"===t){let{encryptionKey:t}=e;return{recovery_key:a.K3.encode(await (0,i.WQ)(t))}}if("google_drive_recovery_secret"===t){let{filename:t,fileId:r}=e;return{filename:t,file_id:r}}if("icloud_recovery_secret"===t){let{recordName:t}=e;return{icloud_record_name:t}}if("recovery_encryption_key"===t)return{};else throw Error("Unknown recovery type: ".concat(t))}},65276:(e,t,r)=>{"use strict";r.d(t,{A:()=>P});var a=r(12192),i=r(39972),n=r(87357),o=r(25129),s=r(69293),c=r(67519),l=r(16150);let d=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","eth_sendTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];var p=r(53262),u=r(95917);async function y(e,t){return await e.wallet.sign({hash:t})}var v=r(16088),h=r(36001).Buffer;async function f(e,t,r){return I(e.wallet.address,t),(0,n.personalSign)({privateKey:function(e){if("private-key"===e.entropyType)return h.from(e.entropy);let t=e.wallet.getHdKey().privateKey;if(!t)throw new i.Pi("wallet_not_on_device","Unable to read private key from HD account");return h.from(t)}(e),data:r})}async function w(e,t,r){return I(e.wallet.address,t),await e.wallet.signTypedData(r)}async function m(e,t,r,a){let i=function(e){var t,r;let{userOperation:a,chainId:i,entrypointAddress:n}=e,o=(0,p.h)([{name:"sender",type:"address"},{name:"nonce",type:"uint256"},{name:"initCode",type:"bytes32"},{name:"callData",type:"bytes32"},{name:"callGasLimit",type:"uint256"},{name:"verificationGasLimit",type:"uint256"},{name:"preVerificationGas",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymasterAndData",type:"bytes32"}],[a.sender,a.nonce,(0,u.S)(null!=(t=a.initCode)?t:"0x"),(0,u.S)(a.callData),a.callGasLimit,a.verificationGasLimit,a.preVerificationGas,a.maxFeePerGas,a.maxPriorityFeePerGas,(0,u.S)(null!=(r=a.paymasterAndData)?r:"0x")]),s=(0,u.S)(o),c=(0,p.h)([{name:"userOpHash",type:"bytes32"},{name:"entryPoint",type:"address"},{name:"chainId",type:"uint256"}],[s,n,BigInt(i)]);return(0,u.S)(c)}({userOperation:t,chainId:a,entrypointAddress:r});return await y(e,i)}async function _(e,t){return await e.wallet.sign({hash:t})}async function g(e,t,r){let{method:a,params:i}=t;if(!d.includes(a))throw Error("Unsupported JSON RPC method: ".concat(a));switch(a){case"personal_sign":return{method:a,data:await f(e,i[1],i[0])};case"eth_populateTransactionRequest":return{method:a,data:await k(e,i[0],r)};case"eth_sign":return I(e.wallet.address,i[0]),{method:a,data:await e.wallet.signMessage({message:i[1]})};case"eth_signTypedData_v4":{let t=function(e){if("string"!=typeof e)return e;try{return JSON.parse(e)}catch(e){throw Error("Failed to deserialize message with error: ".concat(e))}}(i[1]);return{method:a,data:await w(e,i[0],t)}}case"eth_signTransaction":{let t=(0,l._)(i[0]);return{method:a,data:await e.wallet.signTransaction(t)}}case"eth_sendTransaction":return{method:a,data:await b(e,i[0],r)};case"csw_signUserOperation":{let[t,r,n]=i;return{method:a,data:await m(e,t,r,n)}}case"secp256k1_sign":{let[t]=i;return{method:a,data:await _(e,t)}}}}async function b(e,t,r){try{let{chainId:a=c.r.id,...i}=(0,l._)(t),n=(0,v.vo)(a),d=(0,v.vh)(a,r),p=(0,o.F)({chain:n,account:e.wallet,transport:(0,s.L)(d)});return await p.sendTransaction(i)}catch(e){throw E(e)}}async function k(e,t,r){try{let{chainId:a=c.r.id,...i}=(0,l._)(t),n=(0,v.vo)(a),d=(0,v.vh)(a,r),p=(0,o.F)({account:e.wallet.address,chain:n,transport:(0,s.L)(d)}),{type:u,...y}=await p.prepareTransactionRequest(i);return{...y,type:l.k[u]}}catch(e){throw E(e)}}function E(e){let t=e.code,r=e.reason;return"INSUFFICIENT_FUNDS"===t?new i.Pi("insufficient_funds","Wallet has insufficient funds for this transaction"):r?new i.Pi("error",r):"string"==typeof e?Error(e):e}function I(e,t){if(!(0,a.LH)(e,t))throw Error("Signer ".concat(e," can not sign on behalf of ").concat(t))}function P(e,t,r){if(!(0,a.qi)(e.wallet.address))throw new i.Pi("invalid_request_arguments","Failed to service JSON RPC request: missing or invalid wallet address");return g(e,t,r)}},65563:(e,t,r)=>{"use strict";r.d(t,{X:()=>d,k:()=>l});var a=r(23105),i=r(39972),n=r(80780),o=r(25162),s=r(78162);async function c(e,t,r,a,i){let n=await Promise.allSettled(t.map(async t=>{let i=await o.jU(t,s.oG);return await o.Vv(e,i,{typ:"JWT",algorithms:[s.oG],issuer:s.GR,audience:"mfa-".concat(r),subject:a})})),c=n.find(e=>"fulfilled"===e.status);if(!c)throw i("mfa_token_verification_failed",{error:n.filter(e=>"rejected"===e.status).map(e=>e.reason instanceof Error?e.reason.message:typeof e.reason).join("\n")}),n[0].reason;return c.value}async function l(e){let{appId:t,userId:r,token:a,hasSetMfaToken:i}=e;await n.A.set({appId:t,userId:r},{token:a}),i.current=!0}async function d(e){var t;let{appId:r,appClientId:o,userId:s,accessToken:d,mfaMethod:p,mfaCode:u,relyingParty:y,hasSetMfaToken:v,verificationKeys:h,createWalletEvent:f}=e;if(u&&p)try{let e=await a.j2({appId:r,appClientId:o,accessToken:d,method:p,code:u,relyingParty:y});return await l({appId:r,userId:s,token:e.token,hasSetMfaToken:v}),f("mfa_verification_completed",{verificationPath:"mfa_code"}),e.token}catch(e){throw f("mfa_verification_failed",{verificationPath:"mfa_code",error:e instanceof Error?e.message:typeof e}),await n.A.del({appId:r,userId:s}),new i.Pi("missing_or_invalid_mfa","MFA verification failed")}let w=null==(t=await n.A.get({appId:r,userId:s}))?void 0:t.token;if(w)try{return await c(w,h,r,s,f),v.current=!0,f("mfa_verification_completed",{verificationPath:"mfa_storage"}),w}catch(e){throw console.error(e),f("mfa_verification_failed",{verificationPath:"mfa_storage",error:e instanceof Error?e.message:typeof e}),await n.A.del({appId:r,userId:s}),new i.Pi("missing_or_invalid_mfa","MFA verification failed")}if(v.current)throw f("mfa_verification_failed",{verificationPath:"mfa_storage_no_code",error:"MFA token was previously set but not provided"}),console.debug("MFA token was previously set but not provided"),new i.Pi("missing_or_invalid_mfa","MFA verification failed");return null}},72758:(e,t,r)=>{"use strict";r.d(t,{A:()=>l});var a=r(44009),i=r(31461),n=r(12192),o=r(89087);class s extends o.i{async set(e,t){let r=this.getWalletStorageKey(e),a={share:t.share,deviceId:t.deviceId};await this._set(r,a)}async get(e){let t=this.getWalletStorageKey(e);return await this._get(t)}async del(e){let t=this.getWalletStorageKey(e);await this._del(t)}getWalletStorageKey(e){let{appId:t,userId:r,address:a}=e;return"privy_wallet:".concat(t,":").concat(r,":").concat((0,n.qi)(a)?(0,n.py)(a):a)}constructor(e){super(e)}}var c=r(3220);let l=new s((()=>{try{if((0,a.n)()){let e=new c._,t=(0,i.P)();return new a.r(e,t)}if("undefined"!=typeof globalThis&&globalThis.localStorage){globalThis.localStorage.setItem("privy-storage-check","t");let e=globalThis.localStorage.getItem("privy-storage-check");if(globalThis.localStorage.removeItem("privy-storage-check"),"t"!==e)throw console.debug("Localstorage check failed"),Error("Unable to ping localStorage");return globalThis.localStorage}return new c._}catch(e){return e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory."),new c._}})())},72986:e=>{"use strict";e.exports={getGlobalPrivyAuthUrl:()=>"https://auth.privy.io"}},78162:(e,t,r)=>{"use strict";r.d(t,{GR:()=>i,Io:()=>c,cf:()=>o,oG:()=>n});var a=r(25162);let i="privy.io",n="ES256",o="aid",s={att:"pat"};function c(e){return a.iU(e).att===s.att}},79751:(e,t,r)=>{"use strict";function a(e){return!!e.ReactNativeWebView&&e.top===e}function i(e){return a(e)&&navigator.userAgent.includes("Android")}function n(e){let{PRIVY_NATIVE_IOS:t,PRIVY_NATIVE_ANDROID:r,PRIVY_UNITY:n}=e;return r?"native-android":t?"native-ios":n?"unity":i(e)?"expo-android":a(e)?"expo-ios":"web"}r.d(t,{k3:()=>i,l_:()=>a,yS:()=>n})},80015:(e,t,r)=>{"use strict";r.d(t,{WT:()=>l,hf:()=>s,yt:()=>c});var a=r(71246),i=r(23105),n=r(39972);let o="https://api.apple-cloudkit.com/database/1";async function s(e,t,r,a){let n=await (0,i.AI)({appId:e,appClientId:t,accessToken:r,data:{client_type:a}});return{cloudKitContainerIdentifier:n.container_identifier,cloudKitEnvironment:n.environment,cloudKitApiToken:n.api_token}}async function c(e){var t,r,i;let{ckWebAuthToken:s,recoverySecretToStore:c,entropyId:l,appId:d,userId:p,cloudKitContainerIdentifier:u,cloudKitEnvironment:y,cloudKitApiToken:v}=e,h=encodeURIComponent(s),f="".concat(o,"/").concat(u,"/").concat(y,"/private/records/modify?ckAPIToken=").concat(v,"&ckWebAuthToken=").concat(h),w=await a.OT.raw(f,{method:"POST",body:{operations:[{operationType:"create",record:{recordType:"PrivyWallets",fields:{recovery_secret:{value:c},wallet_address:{value:l},app_id:{value:d},user_id:{value:p}}}}]},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==w||null==(t=w._data)?void 0:t.records)||(null==w||null==(r=w._data)?void 0:r.records.length)===0||!(null==(i=w._data.records)?void 0:i[0]))throw new n.RO("no_icloud_record_found","Failed to store wallet: unknown issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"no_icloud_record_found"}});if(w._data.records.length>1)throw new n.RO("multiple_icloud_records_found","Failed to store wallet: multiple iCloud records found for the user",{eventName:"icloud_write_error",payload:{detail:"multiple_icloud_records_found"}});let m=w._data.records[0];if("serverErrorCode"in m)throw console.warn("Unable to store with iCloud: ".concat(m.reason)),new n.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud errored with code ".concat(m.serverErrorCode),{eventName:"icloud_write_error",payload:{detail:"icloud_server_issue",icloud_error_code:m.serverErrorCode,icloud_status:w.status,icloud_error_uuid:m.uuid}});if(w.status>=400)throw new n.RO("unknown_icloud_storage_error","Failed to store wallet: issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"unknown_icloud_server_issue",icloud_status:w.status}});if(c!==m.fields.recovery_secret.value)throw new n.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud stored wallet address does not match expected address.",{eventName:"icloud_write_error",payload:{detail:"wallet_address_mismatch"}});return m.recordName}async function l(e){var t,r,i;let{ckWebAuthToken:s,recordName:c,entropyId:l,cloudKitContainerIdentifier:d,cloudKitEnvironment:p,cloudKitApiToken:u,createWalletEvent:y}=e,v=encodeURIComponent(s),h="".concat(o,"/").concat(d,"/").concat(p,"/private/records/lookup?ckAPIToken=").concat(u,"&ckWebAuthToken=").concat(v),f=await a.OT.raw(h,{method:"POST",body:{records:{recordName:c}},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==f||null==(t=f._data)?void 0:t.records)||(null==f||null==(r=f._data)?void 0:r.records.length)===0||!(null==(i=f._data.records)?void 0:i[0]))throw y("icloud_recovery_error",{detail:"no_icloud_record_found"}),new n.Pi("no_icloud_record_found","Failed to recover wallet: expected an iCloud recovery record, user possibly selected the wrong iCloud account");if(f._data.records.length>1)throw y("icloud_recovery_error",{detail:"multiple_icloud_records_found"}),new n.Pi("multiple_icloud_records_found","Failed to recover wallet: multiple iCloud records found for the user");let w=f._data.records[0];if("serverErrorCode"in w)throw y("icloud_recovery_error",{detail:"icloud_server_issue",icloud_error_code:w.serverErrorCode,icloud_status:f.status,icloud_error_uuid:w.uuid}),console.warn("Unable to recover with iCloud: ".concat(w.reason)),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud errored with code ".concat(w.serverErrorCode));if(f.status>=400)throw y("icloud_recovery_error",{detail:"unknown_icloud_server_issue",icloud_status:f.status}),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: issue fetching recovery secret");if(l!==w.fields.wallet_address.value)throw y("icloud_recovery_error",{detail:"wallet_address_mismatch"}),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud stored wallet address does not match expected address.");return w.fields.recovery_secret.value}},80780:(e,t,r)=>{"use strict";r.d(t,{A:()=>c});var a=r(89087);class i extends a.i{async set(e,t){let r=this.getMfaTokenStorageKey(e);await this._set(r,t)}async get(e){let t=this.getMfaTokenStorageKey(e);return await this._get(t)}async del(e){let t=this.getMfaTokenStorageKey(e);await this._del(t)}getMfaTokenStorageKey(e){let{appId:t,userId:r}=e;return"privy:mfa:".concat(t,":").concat(r)}constructor(e){super(e)}}var n=r(44009),o=r(31461),s=r(3220);let c=new i((()=>{try{if((0,n.n)()){let e=new s._,t=(0,o.P)();return new n.r(e,t)}if("undefined"!=typeof globalThis&&globalThis.localStorage)return globalThis.localStorage}catch(e){e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory.")}return new s._})())},84178:(e,t,r)=>{"use strict";r.d(t,{l:()=>a});let a=(0,r(78273).x)({id:267,name:"Neura Testnet",nativeCurrency:{name:"ANKR",symbol:"ANKR",decimals:18},rpcUrls:{default:{http:["https://testnet.rpc.neuraprotocol.io"],webSocket:["wss://testnet.rpc.neuraprotocol.io"]}},blockExplorers:{default:{name:"Neura Explorer",url:"https://testnet-blockscout.infra.neuraprotocol.io/"}}})},86068:(e,t,r)=>{"use strict";r.d(t,{a:()=>n});var a=r(66875),i=r(62645);async function n(e){let{entropy:t}=e,r=await (0,i.m)(t),n=a.K3.encode(r);return{publicKey:n,privateKey:t,address:n}}},87781:()=>{},88767:(e,t,r)=>{"use strict";r.d(t,{A:()=>u});var a=r(39972),i=r(66875),n=r(85432),o=r(12192),s=r(86068),c=r(23105),l=r(72758);async function d(e){let t,r,{accessToken:a,appId:d,appClientId:p,clientAnalyticsId:u,userId:y,mfaToken:v,entropyId:h,entropyIdVerifier:f}=e,w={appId:d,userId:y,address:h},m=await l.A.get(w);if(!m)return null;let{share:_,deviceId:g}=m;try{let e=await c.u({appId:d,appClientId:p,accessToken:a,clientAnalyticsId:u,mfaToken:v,deviceId:g,entropyKey:h,entropyKeyVerifier:f});t=e.share,r=e.imported}catch(e){var b;if((null==(b=e.data)?void 0:b.code)==="device_revoked"||403===e.status)return await l.A.del(w),null;throw e}try{let e=await (0,n.k)([i.K3.decode(_),i.K3.decode(t)]);if("ethereum-address-verifier"===f&&r){let t=(0,o.st)({entropy:e});if(!(0,o.LH)(h,t.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("ethereum-address-verifier"===f){let t=(0,o.Ay)({entropy:e,walletIndex:0});if(!(0,o.LH)(h,t.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("solana-address-verifier"===f&&r){if((0,o.Wi)({entropy:e}).publicKey.toBase58()!==h)throw Error("Failed to reconstruct the expected public key from Shamir shares.")}else if("solana-address-verifier"===f){if((0,o.kG)({entropy:e,index:0}).publicKey.toBase58()!==h)throw Error("Failed to reconstruct the expected public key from Shamir shares.")}else if("p256"===f){if((await (0,s.a)({entropy:e})).publicKey!==h)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{entropy:e,entropyType:"private-key"}}return{entropy:e,entropyType:r?"private-key":"hd-entropy"}}catch(e){return await l.A.del(w),null}}var p=r(65563);async function u(e){let{accessToken:t,appId:r,appClientId:i,clientAnalyticsId:n,userId:o,mfaCode:s,mfaMethod:c,relyingParty:l,entropyId:u,entropyIdVerifier:y,cache:v,verificationKeys:h,hasSetMfaToken:f,createWalletEvent:w}=e,m=await (0,p.X)({appId:r,appClientId:i,userId:o,accessToken:t,mfaMethod:c,mfaCode:s,relyingParty:l,verificationKeys:h,hasSetMfaToken:f,createWalletEvent:w});if(v&&v.entropyId===u)return{entropy:v.entropy,entropyType:v.entropyType};let _=await d({appId:r,clientAnalyticsId:n,appClientId:i,userId:o,accessToken:t,entropyId:u,entropyIdVerifier:y,mfaToken:m});if(!_)throw new a.Pi("wallet_not_on_device","Failed to initialize: '".concat(u,"' not loaded on this device"));return _}},89087:(e,t,r)=>{"use strict";r.d(t,{i:()=>a});class a{async _set(e,t){await this.storage.setItem(e,JSON.stringify(t))}async _get(e){let t=await this.storage.getItem(e);if("string"!=typeof t)return null;try{return JSON.parse(t)}catch(t){return console.warn("Unable to parse value from storage for key ".concat(e,". Error: ").concat(t)),await this.storage.removeItem(e),null}}async _del(e){await this.storage.removeItem(e)}constructor(e){this.storage=e}}},90093:(e,t,r)=>{"use strict";r.d(t,{E:()=>s});var a=r(91916),i=r(86989),n=r(95877),o=r(92146);function s(e){let{entropy:t,index:r,pathType:s}=e,l=a.c.fromMasterSeed((0,i.kw)((0,i.VF)(t,n.p))).derive(c(r,s));if(!l.publicKey||!l.privateKey)throw Error("Error deriving HD node for entropy");let d="taproot"===s?(0,o.bv)("tr",l.privateKey):(0,o.bv)("wpkh",l.privateKey);if(!d)throw Error("Error deriving address from private key");return{_node:l,address:d,privateKey:l.privateKey,publicKey:l.publicKey}}let c=(e,t)=>"taproot"===t?"m/86'/0'/0'/0/".concat(e):"m/84'/0'/0'/0/".concat(e)},94355:()=>{},96827:(e,t,r)=>{"use strict";r.d(t,{z:()=>s});var a=r(39972),i=r(30604),n=r(63892),o=r(12192);async function s(e){let{appId:t,appClientId:r,userId:s,walletAddress:c,accessToken:l,clientType:d,recoveryPassword:p,recoveryMethod:u,recoveryAccessToken:y,recoveryPin:v,recoveryKey:h,recoverySecretOverride:f,iCloudRecordNameOverride:w,createWalletEvent:m}=e,_=p||v;if(void 0!==_&&!(0,o.jt)(_))throw new a.Pi("invalid_request_arguments","Failed to create wallet: invalid recovery pin");if("icloud-native"===u&&(!f||!w))throw new a.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName must be overridden for icloud-native recovery");if("icloud-native"!==u&&(f||w))throw new a.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName can only be overridden for icloud-native recovery");if("recovery-encryption-key"===u&&!h)throw new a.Pi("invalid_request_arguments","Failed to create wallet: invalid recovery key");let g=u?i.Z[u]:void 0;g||(g=void 0!==_?"user_passcode_derived_recovery_key":"privy_generated_recovery_key");let b=(0,n.Zw)({recoveryType:g,appId:t,appClientId:r,userId:s,entropyId:c,clientType:d,recoveryPassword:_,recoveryKey:h,recoveryAccessToken:y,accessToken:l,recoverySecretOverride:f,iCloudRecordNameOverride:w,createWalletEvent:m}),{encryptionKey:k,walletRecoveryOutput:E}=await (0,n.cq)(b);return{encryptionKey:k,walletRecoveryOutput:E,recoveryType:g}}},99798:(e,t,r)=>{"use strict";r(36001).Buffer;t.Ib=function(e){let t=e.trim();return t.startsWith("-----BEGIN PUBLIC KEY-----")?t:function(e,t,r){let a=r?"\n":"",i=e.replaceAll(/(.{64})/g,`$1${a}`);switch(t){case"spki":return`-----BEGIN PUBLIC KEY-----${a}${i}${a}-----END PUBLIC KEY-----`;case"pkcs8":return`-----BEGIN PRIVATE KEY-----${a}${i}${a}-----END PRIVATE KEY-----`;default:throw Error("Invalid format for PEM encoding")}}(t,"spki",!0)},t.MC=a,t.fj=i,"undefined"==typeof crypto&&(globalThis.crypto=r(18842).webcrypto);async function a(e){return n(await crypto.subtle.exportKey("spki",e),"PUBLIC KEY")}async function i(e){return o(await crypto.subtle.exportKey("pkcs8",e))}function n(e,t){let r=o(e),a=r.match(/.{1,64}/g);return`-----BEGIN ${t}-----
`+(a?a.join("\n"):r)+`
-----END ${t}-----`}function o(e){return function(e){return btoa(String.fromCharCode(...e))}(new Uint8Array(e))}}}]);